local function LoadPlayerTab(MainWindow, UI_Library)
    local Module = {
        state = {
            selectedPlayer = nil,
            allPlayers = {},
            isSitting = false,
            isLoopHeadSit = false,
            isOrbiting = false,
            isMirroring = false,
            isFloating = false,
            isShadowFollowing = false,
            isReversing = false,
            isDancing = false,
            isShadowAscending = false,
            isMonitoring = false,
            isTeleportingSame = false,
            isTeleportingAll = false,
            isAntiFollowing = false,
            isSpinning = false,
            isShaking = false,
            isFaceStanding = false,
            isBackSitting = false
        },
        connections = {
            playerListRefresh = nil,
            headSit = nil,
            orbit = nil,
            mirror = nil,
            float = nil,
            shadow = nil,
            reverse = nil,
            dance = nil,
            shadowAscend = nil,
            monitor = nil,
            antiFollow = nil,
            spin = nil,
            shake = nil,
            faceStand = nil,
            backSit = nil,
            teleportThreads = {}
        },
        config = {
            orbitRadius = 5,
            orbitSpeed = 0.05,
            floatHeight = 3,
            shadowAscendSpeed = 0.5,
            teleportInterval = 0.3,
            mirrorDistance = 4,
            antiFollowDistance = 8,
            spinSpeed = 5,
            shakeIntensity = 2
        }
    }

    local function getLocalCharacter()
        local localPlayer = game.Players.LocalPlayer
        if not localPlayer then return nil end
        return localPlayer.Character or localPlayer.CharacterAdded:Wait()
    end

    local function getTargetPlayer(playerName)
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Name == playerName or player.DisplayName == playerName then
                return player
            end
        end
        return nil
    end

    local function disableCollision(localChar)
        if not localChar then return end
        for _, part in ipairs(localChar:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.CanTouch = false
            end
        end
    end

    local function enableCollision(localChar)
        if not localChar then return end
        for _, part in ipairs(localChar:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.CanTouch = true
            end
        end
    end

    local function cleanAllResources()
        for _, conn in pairs(Module.connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            elseif typeof(conn) == "table" then
                for _, thread in ipairs(conn) do
                    if thread then task.cancel(thread) end
                end
            end
        end
        for k in pairs(Module.state) do
            if type(Module.state[k]) == "boolean" then
                Module.state[k] = false
            elseif type(Module.state[k]) == "table" then
                Module.state[k] = {}
            else
                Module.state[k] = nil
            end
        end
        Module.connections = {teleportThreads = {}}
        
        local localChar = getLocalCharacter()
        if localChar then
            enableCollision(localChar)
        end
    end

    local function showNotify(title, text, duration)
        if UI_Library and UI_Library.Notification then
            UI_Library:Notification({Title = title, Text = text, Duration = duration or 3})
        else
            pcall(function()
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = title,
                    Text = text,
                    Duration = duration or 3
                })
            end)
        end
    end

    local function stopHeadSit()
        Module.state.isSitting = false
        if Module.connections.headSit then
            Module.connections.headSit:Disconnect()
            Module.connections.headSit = nil
        end

        local localChar = getLocalCharacter()
        if localChar then
            local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
            if localHumanoid then
                localHumanoid.Sit = false
                enableCollision(localChar)
            end
        end
        showNotify("坐头停止", "已停止坐头", 3)
    end

    local function startHeadSit(targetPlayerName)
        if Module.connections.headSit then
            Module.connections.headSit:Disconnect()
            Module.connections.headSit = nil
        end
        Module.state.isSitting = true

        local localPlayer = game.Players.LocalPlayer
        local localChar = getLocalCharacter()
        if not localChar then
            showNotify("坐头失败", "本地角色未加载", 3)
            Module.state.isSitting = false
            return
        end
        local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localHumanoid or not localRoot then
            showNotify("坐头失败", "角色缺少关键部件", 3)
            Module.state.isSitting = false
            return
        end

        disableCollision(localChar)
        localHumanoid.Sit = true

        Module.connections.headSit = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isSitting or not localChar.Parent then
                    if Module.state.isLoopHeadSit and localPlayer.Character then
                        task.wait(1)
                        if Module.state.isLoopHeadSit and Module.state.selectedPlayer then
                            startHeadSit(Module.state.selectedPlayer)
                        end
                    else
                        cleanAllResources()
                    end
                    return
                end

                local targetPlayer = getTargetPlayer(targetPlayerName)
                if not targetPlayer or not targetPlayer.Character then
                    showNotify("坐头停止", "目标玩家角色消失", 3)
                    if Module.state.isLoopHeadSit then
                        task.wait(1)
                        if Module.state.isLoopHeadSit and Module.state.selectedPlayer then
                            startHeadSit(Module.state.selectedPlayer)
                        end
                    else
                        cleanAllResources()
                    end
                    return
                end
                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local headPos = targetRoot.CFrame * CFrame.new(0, 1.6, 0.4)
                localRoot.CFrame = headPos
                disableCollision(localChar)
            end)
        end)

        showNotify("坐头启动", "已开始坐 " .. targetPlayerName .. " 的头", 3)
    end

    local function stopAllTeleports()
        for _, thread in ipairs(Module.connections.teleportThreads) do
            if thread then task.cancel(thread) end
        end
        Module.connections.teleportThreads = {}
    end

    local function teleportToPlayer(targetPlayer)
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            localRoot.CFrame = targetRoot.CFrame
        end
    end

    local function startOrbit(targetPlayer)
        stopAllTeleports()
        Module.state.isOrbiting = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        local angle = 0
        Module.connections.orbit = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isOrbiting or not localChar.Parent then
                    if Module.state.isOrbiting and localChar then
                        task.wait(1)
                        if Module.state.isOrbiting and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startOrbit(newTarget) end
                        end
                    else
                        Module.connections.orbit:Disconnect()
                        Module.connections.orbit = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("环绕停止", "目标玩家角色消失", 3)
                    Module.connections.orbit:Disconnect()
                    Module.connections.orbit = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                angle = angle + Module.config.orbitSpeed
                if angle > 360 then angle = 0 end
                local offset = Vector3.new(
                    math.cos(angle) * Module.config.orbitRadius,
                    2,
                    math.sin(angle) * Module.config.orbitRadius
                )
                localRoot.CFrame = CFrame.new(targetRoot.Position + offset, targetRoot.Position)
                disableCollision(localChar)
            end)
        end)
    end

    local function stopOrbit()
        Module.state.isOrbiting = false
        if Module.connections.orbit then
            Module.connections.orbit:Disconnect()
            Module.connections.orbit = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startMirror(targetPlayer)
        Module.state.isMirroring = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.mirror = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isMirroring or not localChar.Parent then
                    if Module.state.isMirroring and localChar then
                        task.wait(1)
                        if Module.state.isMirroring and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startMirror(newTarget) end
                        end
                    else
                        Module.connections.mirror:Disconnect()
                        Module.connections.mirror = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("镜像停止", "目标玩家角色消失", 3)
                    Module.connections.mirror:Disconnect()
                    Module.connections.mirror = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local mirrorPos = targetRoot.CFrame * CFrame.new(Module.config.mirrorDistance, 0, 0)
                local lookVector = targetRoot.CFrame.LookVector
                local mirrorCFrame = CFrame.new(mirrorPos.Position) * CFrame.Angles(0, math.pi, 0)
                localRoot.CFrame = mirrorCFrame
                disableCollision(localChar)
            end)
        end)
    end

    local function stopMirror()
        Module.state.isMirroring = false
        if Module.connections.mirror then
            Module.connections.mirror:Disconnect()
            Module.connections.mirror = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startFloat(targetPlayer)
        Module.state.isFloating = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.float = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isFloating or not localChar.Parent then
                    if Module.state.isFloating and localChar then
                        task.wait(1)
                        if Module.state.isFloating and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startFloat(newTarget) end
                        end
                    else
                        Module.connections.float:Disconnect()
                        Module.connections.float = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("漂浮停止", "目标玩家角色消失", 3)
                    Module.connections.float:Disconnect()
                    Module.connections.float = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local floatPos = targetRoot.Position + Vector3.new(0, Module.config.floatHeight, 0)
                localRoot.CFrame = CFrame.new(floatPos)
                disableCollision(localChar)
            end)
        end)
    end

    local function stopFloat()
        Module.state.isFloating = false
        if Module.connections.float then
            Module.connections.float:Disconnect()
            Module.connections.float = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startShadow(targetPlayer)
        Module.state.isShadowFollowing = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.shadow = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isShadowFollowing or not localChar.Parent then
                    if Module.state.isShadowFollowing and localChar then
                        task.wait(1)
                        if Module.state.isShadowFollowing and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startShadow(newTarget) end
                        end
                    else
                        Module.connections.shadow:Disconnect()
                        Module.connections.shadow = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("影子停止", "目标玩家角色消失", 3)
                    Module.connections.shadow:Disconnect()
                    Module.connections.shadow = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local shadowPos = targetRoot.Position - Vector3.new(0, 3, 0)
                localRoot.CFrame = CFrame.new(shadowPos)
                disableCollision(localChar)
            end)
        end)
    end

    local function stopShadow()
        Module.state.isShadowFollowing = false
        if Module.connections.shadow then
            Module.connections.shadow:Disconnect()
            Module.connections.shadow = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startAntiFollow(targetPlayer)
        Module.state.isAntiFollowing = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.antiFollow = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isAntiFollowing or not localChar.Parent then
                    if Module.state.isAntiFollowing and localChar then
                        task.wait(1)
                        if Module.state.isAntiFollowing and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startAntiFollow(newTarget) end
                        end
                    else
                        Module.connections.antiFollow:Disconnect()
                        Module.connections.antiFollow = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("反向停止", "目标玩家角色消失", 3)
                    Module.connections.antiFollow:Disconnect()
                    Module.connections.antiFollow = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local antiPos = targetRoot.Position - targetRoot.CFrame.LookVector * Module.config.antiFollowDistance
                localRoot.CFrame = CFrame.new(antiPos)
                disableCollision(localChar)
            end)
        end)
    end

    local function stopAntiFollow()
        Module.state.isAntiFollowing = false
        if Module.connections.antiFollow then
            Module.connections.antiFollow:Disconnect()
            Module.connections.antiFollow = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startSpin(targetPlayer)
        Module.state.isSpinning = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        local spinAngle = 0
        Module.connections.spin = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isSpinning or not localChar.Parent then
                    if Module.state.isSpinning and localChar then
                        task.wait(1)
                        if Module.state.isSpinning and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startSpin(newTarget) end
                        end
                    else
                        Module.connections.spin:Disconnect()
                        Module.connections.spin = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("旋转停止", "目标玩家角色消失", 3)
                    Module.connections.spin:Disconnect()
                    Module.connections.spin = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                spinAngle = spinAngle + Module.config.spinSpeed
                local offset = Vector3.new(
                    math.cos(spinAngle) * 3,
                    0,
                    math.sin(spinAngle) * 3
                )
                local spinCFrame = CFrame.new(targetRoot.Position + offset) * CFrame.Angles(0, spinAngle, 0)
                localRoot.CFrame = spinCFrame
                disableCollision(localChar)
            end)
        end)
    end

    local function stopSpin()
        Module.state.isSpinning = false
        if Module.connections.spin then
            Module.connections.spin:Disconnect()
            Module.connections.spin = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startShake(targetPlayer)
        Module.state.isShaking = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.shake = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isShaking or not localChar.Parent then
                    if Module.state.isShaking and localChar then
                        task.wait(1)
                        if Module.state.isShaking and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startShake(newTarget) end
                        end
                    else
                        Module.connections.shake:Disconnect()
                        Module.connections.shake = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("抖动停止", "目标玩家角色消失", 3)
                    Module.connections.shake:Disconnect()
                    Module.connections.shake = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local shakeOffset = Vector3.new(
                    math.random(-Module.config.shakeIntensity, Module.config.shakeIntensity),
                    math.random(-Module.config.shakeIntensity, Module.config.shakeIntensity),
                    math.random(-Module.config.shakeIntensity, Module.config.shakeIntensity)
                )
                localRoot.CFrame = CFrame.new(targetRoot.Position + shakeOffset)
                disableCollision(localChar)
            end)
        end)
    end

    local function stopShake()
        Module.state.isShaking = false
        if Module.connections.shake then
            Module.connections.shake:Disconnect()
            Module.connections.shake = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startFaceStand(targetPlayer)
        Module.state.isFaceStanding = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end

        disableCollision(localChar)

        Module.connections.faceStand = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isFaceStanding or not localChar.Parent then
                    if Module.state.isFaceStanding and localChar then
                        task.wait(1)
                        if Module.state.isFaceStanding and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startFaceStand(newTarget) end
                        end
                    else
                        Module.connections.faceStand:Disconnect()
                        Module.connections.faceStand = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("脸上站立停止", "目标玩家角色消失", 3)
                    Module.connections.faceStand:Disconnect()
                    Module.connections.faceStand = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local facePos = targetRoot.CFrame * CFrame.new(0, 2.5, 0.5)
                localRoot.CFrame = facePos
                disableCollision(localChar)
            end)
        end)
    end

    local function stopFaceStand()
        Module.state.isFaceStanding = false
        if Module.connections.faceStand then
            Module.connections.faceStand:Disconnect()
            Module.connections.faceStand = nil
        end
        local localChar = getLocalCharacter()
        if localChar then enableCollision(localChar) end
    end

    local function startBackSit(targetPlayer)
        Module.state.isBackSitting = true
        local localChar = getLocalCharacter()
        if not localChar then return end
        local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localHumanoid or not localRoot then return end

        disableCollision(localChar)
        localHumanoid.Sit = true

        Module.connections.backSit = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isBackSitting or not localChar.Parent then
                    if Module.state.isBackSitting and localChar then
                        task.wait(1)
                        if Module.state.isBackSitting and Module.state.selectedPlayer then
                            local newTarget = getTargetPlayer(Module.state.selectedPlayer)
                            if newTarget then startBackSit(newTarget) end
                        end
                    else
                        Module.connections.backSit:Disconnect()
                        Module.connections.backSit = nil
                        enableCollision(localChar)
                    end
                    return
                end

                if not targetPlayer.Character then
                    showNotify("背上坐下停止", "目标玩家角色消失", 3)
                    Module.connections.backSit:Disconnect()
                    Module.connections.backSit = nil
                    enableCollision(localChar)
                    return
                end

                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not targetRoot then return end

                local backPos = targetRoot.CFrame * CFrame.new(0, 0.5, -1.5)
                localRoot.CFrame = backPos
                disableCollision(localChar)
                localHumanoid.Sit = true
            end)
        end)
    end

    local function stopBackSit()
        Module.state.isBackSitting = false
        if Module.connections.backSit then
            Module.connections.backSit:Disconnect()
            Module.connections.backSit = nil
        end
        local localChar = getLocalCharacter()
        if localChar then
            local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
            if localHumanoid then
                localHumanoid.Sit = false
            end
            enableCollision(localChar)
        end
    end

    local function startMonitor(targetPlayer)
        Module.state.isMonitoring = true
        local camera = workspace.CurrentCamera
        if not camera then return end

        Module.connections.monitor = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                if not Module.state.isMonitoring or not targetPlayer.Character then
                    Module.connections.monitor:Disconnect()
                    Module.connections.monitor = nil
                    local localChar = getLocalCharacter()
                    if localChar then
                        local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
                        if localHumanoid then
                            camera.CameraSubject = localHumanoid
                        end
                    end
                    return
                end

                local targetSubject = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if not targetSubject then
                    targetSubject = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                end
                if targetSubject then
                    camera.CameraSubject = targetSubject
                end
            end)
        end)
        showNotify("监视启动", "已开始监视 " .. targetPlayer.Name, 3)
    end

    local function stopMonitor()
        Module.state.isMonitoring = false
        if Module.connections.monitor then
            Module.connections.monitor:Disconnect()
            Module.connections.monitor = nil
        end
        local localChar = getLocalCharacter()
        if localChar then
            local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
            if localHumanoid then
                workspace.CurrentCamera.CameraSubject = localHumanoid
            end
        end
        showNotify("监视停止", "已停止监视", 3)
    end

    local PlayerTab = MainWindow:Tab("玩家", '5436396975')

    local SelectSection = PlayerTab:section("选择玩家", true)
    local PlayerDropdown = SelectSection:Dropdown("选择玩家", "PlayerSelect", Module.state.allPlayers, function(Value)
        Module.state.selectedPlayer = Value
        showNotify("选择玩家", "已选择 " .. Value, 2)
    end)

    Module.connections.playerListRefresh = game:GetService("RunService").Heartbeat:Connect(function()
        pcall(function()
            local newPlayerList = {}
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer then
                    table.insert(newPlayerList, player.Name)
                end
            end
            if #newPlayerList ~= #Module.state.allPlayers then
                Module.state.allPlayers = newPlayerList
                PlayerDropdown:SetOptions(Module.state.allPlayers)
            end
        end)
    end)

    local HeadSitSection = PlayerTab:section("坐头功能", true)
    HeadSitSection:Button("坐选定玩家头上", function()
        if not Module.state.selectedPlayer then
            showNotify("选择玩家", "请先从下拉框选择玩家", 3)
            return
        end
        stopHeadSit()
        startHeadSit(Module.state.selectedPlayer)
    end)

    HeadSitSection:Toggle("循环坐头（死亡重生后继续）", "LoopHeadSit", false, function(Value)
        Module.state.isLoopHeadSit = Value
        if Value and Module.state.selectedPlayer then
            stopHeadSit()
            startHeadSit(Module.state.selectedPlayer)
        else
            stopHeadSit()
        end
    end)

    HeadSitSection:Button("停止坐头", stopHeadSit)

    local TeleportSection = PlayerTab:section("传送功能", true)
    TeleportSection:Button("传送到选定玩家", function()
        if not Module.state.selectedPlayer then
            showNotify("选择玩家", "请先从下拉框选择玩家", 3)
            return
        end
        local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
        if not targetPlayer or not targetPlayer.Character then
            showNotify("传送失败", "目标玩家角色不存在", 3)
            return
        end
        teleportToPlayer(targetPlayer)
        showNotify("传送成功", "已传送到 " .. targetPlayer.Name, 3)
    end)

    TeleportSection:Toggle("循环传送同个玩家", "LoopTeleportSame", false, function(Value)
        Module.state.isTeleportingSame = Value
        if Value then
            stopAllTeleports()
            local thread = task.spawn(function()
                while Module.state.isTeleportingSame do
                    if not Module.state.selectedPlayer then break end
                    local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
                    if targetPlayer and targetPlayer.Character then
                        teleportToPlayer(targetPlayer)
                    end
                    task.wait(Module.config.teleportInterval)
                end
            end)
            table.insert(Module.connections.teleportThreads, thread)
        else
            stopAllTeleports()
        end
    end)

    TeleportSection:Toggle("循环传送所有玩家", "LoopTeleportAll", false, function(Value)
        Module.state.isTeleportingAll = Value
        if Value then
            stopAllTeleports()
            local thread = task.spawn(function()
                while Module.state.isTeleportingAll do
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if not Module.state.isTeleportingAll then break end
                        if player ~= game.Players.LocalPlayer and player.Character then
                            teleportToPlayer(player)
                            task.wait(Module.config.teleportInterval)
                        end
                    end
                end
            end)
            table.insert(Module.connections.teleportThreads, thread)
        else
            stopAllTeleports()
        end
    end)

    local MonitorSection = PlayerTab:section("视角监视", true)
    MonitorSection:Button("开始监视选定玩家", function()
        if not Module.state.selectedPlayer then
            showNotify("选择玩家", "请先从下拉框选择玩家", 3)
            return
        end
        local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
        if not targetPlayer then
            showNotify("监视失败", "目标玩家不存在", 3)
            return
        end
        stopMonitor()
        startMonitor(targetPlayer)
    end)

    MonitorSection:Button("停止监视", stopMonitor)

    local FollowSection = PlayerTab:section("恶搞跟随", true)
    
    FollowSection:Toggle("旋转环绕跟随", "OrbitFollow", false, function(Value)
        Module.state.isOrbiting = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isOrbiting = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isOrbiting = false
                return
            end
            stopOrbit()
            startOrbit(targetPlayer)
        else
            stopOrbit()
        end
    end)

    FollowSection:Toggle("镜像跟随", "MirrorFollow", false, function(Value)
        Module.state.isMirroring = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isMirroring = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isMirroring = false
                return
            end
            stopMirror()
            startMirror(targetPlayer)
        else
            stopMirror()
        end
    end)

    FollowSection:Toggle("漂浮跟随", "FloatFollow", false, function(Value)
        Module.state.isFloating = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isFloating = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isFloating = false
                return
            end
            stopFloat()
            startFloat(targetPlayer)
        else
            stopFloat()
        end
    end)

    FollowSection:Toggle("影子跟随", "ShadowFollow", false, function(Value)
        Module.state.isShadowFollowing = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isShadowFollowing = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isShadowFollowing = false
                return
            end
            stopShadow()
            startShadow(targetPlayer)
        else
            stopShadow()
        end
    end)

    FollowSection:Toggle("反向跟随", "AntiFollow", false, function(Value)
        Module.state.isAntiFollowing = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isAntiFollowing = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isAntiFollowing = false
                return
            end
            stopAntiFollow()
            startAntiFollow(targetPlayer)
        else
            stopAntiFollow()
        end
    end)

    FollowSection:Toggle("旋转跟随", "SpinFollow", false, function(Value)
        Module.state.isSpinning = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isSpinning = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isSpinning = false
                return
            end
            stopSpin()
            startSpin(targetPlayer)
        else
            stopSpin()
        end
    end)

    FollowSection:Toggle("抖动跟随", "ShakeFollow", false, function(Value)
        Module.state.isShaking = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isShaking = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isShaking = false
                return
            end
            stopShake()
            startShake(targetPlayer)
        else
            stopShake()
        end
    end)

    FollowSection:Toggle("站在玩家脸上", "FaceStand", false, function(Value)
        Module.state.isFaceStanding = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isFaceStanding = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isFaceStanding = false
                return
            end
            stopFaceStand()
            startFaceStand(targetPlayer)
        else
            stopFaceStand()
        end
    end)

    FollowSection:Toggle("坐在玩家背上", "BackSit", false, function(Value)
        Module.state.isBackSitting = Value
        if Value then
            if not Module.state.selectedPlayer then
                showNotify("选择玩家", "请先从下拉框选择玩家", 3)
                Module.state.isBackSitting = false
                return
            end
            local targetPlayer = getTargetPlayer(Module.state.selectedPlayer)
            if not targetPlayer or not targetPlayer.Character then
                showNotify("跟随失败", "目标玩家角色不存在", 3)
                Module.state.isBackSitting = false
                return
            end
            stopBackSit()
            startBackSit(targetPlayer)
        else
            stopBackSit()
        end
    end)

    FollowSection:Button("停止所有跟随", function()
        stopOrbit()
        stopMirror()
        stopFloat()
        stopShadow()
        stopAntiFollow()
        stopSpin()
        stopShake()
        stopFaceStand()
        stopBackSit()
        showNotify("跟随停止", "已停止所有恶搞跟随", 3)
    end)

    game.Players.LocalPlayer.CharacterAdded:Connect(function()
        if Module.state.isLoopHeadSit and Module.state.selectedPlayer then
            task.wait(1)
            startHeadSit(Module.state.selectedPlayer)
        end
    end)

    local function onScriptDestroy()
        cleanAllResources()
    end
    if script and script.Parent then
        script.Parent.AncestryChanged:Connect(function(_, newParent)
            if not newParent then
                onScriptDestroy()
            end
        end)
    end

    return {
        Cleanup = cleanAllResources,
        SelectPlayer = function(playerName)
            Module.state.selectedPlayer = playerName
        end
    }
end

return {
    LoadPlayerTab = LoadPlayerTab
}